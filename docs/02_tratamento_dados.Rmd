---
title: "02_tratamento_dados"
output: html_document
date: "2025-04-26"
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE, 
                      error = FALSE, 
                      warning = FALSE)
```


### üìÑ Sobre os Dados

Permiss√µes e Uso: Todos os dados do Climate TRACE est√£o dispon√≠veis gratuitamente sob a Licen√ßa P√∫blica Internacional Creative Commons Atribui√ß√£o 4.0, salvo indica√ß√£o em contr√°rio.

Forma sugerida de cita√ß√£o: Para fontes de diferentes setores ou dados globais acessados e baixados, utilize a seguinte cita√ß√£o:
Climate TRACE (2025). Climate TRACE Emissions Inventory v4.2.0. Dispon√≠vel em: https://climatetrace.org. Acessado em: [inserir data de acesso].

Para cita√ß√µes espec√≠ficas por setor, consulte a se√ß√£o correspondente na plataforma.

### üìÅ Arquivos Dispon√≠veis

A seguir, uma breve descri√ß√£o dos arquivos inclu√≠dos no pacote de dados baixado da plataforma Climate TRACE:

 + `detailed_data_schema.csv` - Arquivo com o mapeamento e a explica√ß√£o do significado de cada coluna dos dados para todos os diferentes subsetores.

 +  `<nome-do-subsetor>_emissions_sources.csv` - Cont√©m os dados de emiss√µes no n√≠vel de fonte de emiss√£o para todos os subsetores monitorados pela Climate TRACE.

 + `<nome-do-subsetor>_country_emissions.csv` - Cont√©m os dados de emiss√µes no n√≠vel de pa√≠s para todos os subsetores monitorados pela Climate TRACE.

 +  `<nome-do-subsetor>_emissions_sources_confidence.csv` - Arquivo que especifica a classifica√ß√£o de confian√ßa dos dados reportados pelas fontes de emiss√£o, referenciando o arquivo <subsetor>_emissions_sources.csv.

 +  `<nome-do-subsetor>_emissions_sources_ownership.csv` - Cont√©m informa√ß√µes sobre a propriedade das fontes de emiss√£o listadas no arquivo `<subsetor>_emissions_sources.csv.`

üîó Observa√ß√£o: A lista completa de setores de emiss√£o para os quais a Climate TRACE fornece dados est√° dispon√≠vel no site: https://climatetrace.org/sectors.

Para alguns setores, h√° dados geoespaciais adicionais n√£o inclu√≠dos neste pacote de download. Para solicit√°-los, entre em contato pelo e-mail: coalition@climatetrace.org.

### üìÑ Sobre os Dados

Para mais informa√ß√µes sobre a origem, metodologia e estrutura dos dados utilizados, acesse o documento oficial disponibilizado pela Climate TRACE:

üì• Clique aqui para baixar o arquivo [about_the_data.pdf](https://arpanosso.github.io//mestrado-durigan-remocoes-co2//about_the_data.pdf) e [about_the_data_v4_2_0.pdf](https://arpanosso.github.io//mestrado-durigan-remocoes-co2//about_the_data_v4_2_0.pdf)

### üîçüìÅ Encontrando os arquivos `.csv`

```{r,eval=FALSE}
tbl_directorys <- as_tibble(
  list.files("data-raw/BRA/",
             full.names = TRUE,
             recursive = TRUE)) %>%
  filter(str_detect(value, "emissions_sources.csv"))

# Extraindo os caminhos dos arquvios
value <- tbl_directorys %>% pull(value)

# Mapeando Transportation -------------------------------------------------
trans_values <- tbl_directorys %>%
  filter(str_detect(value,"transportation")) %>%
  pull(value)

# Contando as linhas dos arquivos
# row_count <- function(sector_name){
#   read.csv(sector_name) %>%
#     nrow()
# }
# row_count(value[1])
# map_dbl(value, row_count) %>% sum

# Atualizando o banco todo ------------------------------------------------
# Empilhando todos os arquivos no objeto dados
# my_file_read(value[1])
dados <- map_dfr(value, my_file_read)
glimpse(dados)

# Num√©ro de posi√ß√µes no caminho divididas por "/"
n_position <- ncol(str_split(tbl_directorys[1,1],"/",simplify = TRUE))


# Tratanto as colunas de data, nome de setores e sub setores
dados <- dados %>%
  mutate(
    start_time = as_date(start_time),
    end_time = as_date(end_time),
    created_date = as_date(created_date),
    modified_date = as_date(modified_date),
    year = lubridate::year(end_time)
  ) %>%
  mutate(
    sector_name = str_split(directory,
                            "/",
                            simplify = TRUE)[,n_position -1],
    sub_sector = str_split(directory,
                           "/",
                           simplify = TRUE)[,n_position],
    sub_sector = str_remove(sub_sector,"_emissions_sources.csv|_country_emissions.csv")
  )
dados$sector_name %>% unique()
dados$sub_sector %>% unique()
dados$year %>% table()


# agrupando a base por nome e coordenada
# Classificando o ponto em um estado
base_sigla_uf <- dados %>%
  group_by(source_name, lon, lat) %>%
  summarise(
    ano = mean(year)
  ) %>%
  mutate(
    sigla_uf = get_geobr_state(lon,lat),
    biome = get_geobr_biomes(lon,lat),
    flag_conservation = get_geobr_conservation(lon,lat),
    flag_indigenous = get_geobr_indigenous(lon,lat)
  )

### testando flag_indigenous
# base_sigla_uf %>%
#   filter(flag_indigenous) %>%
#   ggplot(aes(x=lon,y=lat))+
#   geom_point()

# indigenous   %>%
#   ggplot() +
#   geom_sf(fill="white", color="black",
#           size=.15, show.legend = FALSE) +
#   geom_point(
#     data = base_sigla_uf %>%
#       filter(flag_indigenous),
#     aes(lon,lat))


### testando flag_conservation
# base_sigla_uf %>%
#   filter(flag_conservation) %>%
#   ggplot(aes(x=lon,y=lat))+
#   geom_point()

# conservation   %>%
#   ggplot() +
#   geom_sf(fill="white", color="black",
#           size=.15, show.legend = FALSE) +
#   geom_point(
#     data = base_sigla_uf %>%
#       filter(flag_conservation),
#     aes(lon,lat))

### testando classifica√ß√£o por bioma
# base_sigla_uf %>%
#   ggplot(aes(x=lon,y=lat,col=biome))+
#   geom_point()
# base_sigla_uf$biome %>% unique() == "Amaz√¥nia"
#
# base_sigla_uf %>%
#   mutate(
#     biome_n = biome == "Amaz√¥nia"
#   ) %>% glimpse()

### Arrumando classifica√ß√£o
# base_sigla_uf %>%
#   mutate(
#     biome_n = case_when(
#         biome=='Other'& lon>= -45 & lat < -6~'AF',
#         biome == "Amaz√¥nia" ~ "AMZ",
#         biome=='Other'& lon< -45 & lat >=-10 ~'AMZ',
#         biome == 'Mata Atl√¢ntica' & lon> -40 & lat < -20 ~'Other',
#         biome == 'Mata Atl√¢ntica' & lon> -34 & lat > -5 ~'Other',
#         biome == 'Mata Atl√¢ntica' ~ 'AF',
#         biome=='Cerrado'~'CERR',
#         biome =='Pampa'~'PMP',
#         biome == 'Pantanal' ~ 'PNT',
#         biome=='Caatinga'~'CAAT',
#         TRUE ~ 'Other'
#       )
#   ) %>%
#   ggplot(aes(x=lon,y=lat,color=biome_n))+
#   geom_point()

base_sigla_uf <- base_sigla_uf %>%
  mutate(
    biomes =
      case_when(
        biome=='Other'& lon>=-45 & lat <0~'AF',
        biome=='Amaz√¥nia'~'AMZ',
        biome=='Other'& lon< -45 & lat >=-10 ~'AMZ',
        biome == 'Mata Atl√¢ntica' & lon> -40 & lat < -20 ~'Other',
        biome == 'Mata Atl√¢ntica' & lon> -34 & lat > -5 ~'Other',
        biome == 'Mata Atl√¢ntica' ~ 'AF',
        biome=='Cerrado'~'CERR',
        biome =='Pampa'~'PMP',
        biome == 'Pantanal' ~ 'PNT',
        biome=='Caatinga'~'CAAT',
        .default = 'Other'
      )
    )

# base_sigla_uf %>%
#   ggplot(aes(x=lon,y=lat,col=biomes))+
#   geom_point()

###
# Classificando pelo pol da cidade ----------------------------------------
base_sigla_uf$sigla_uf %>% unique()
citys <- geobr::read_municipality()
resul <- vector()
estado <- base_sigla_uf$sigla_uf
tictoc::tic()
for(i in 1:nrow(base_sigla_uf)){
  if(estado[i]!="Other"){
    my_citys_obj <- citys %>%
      filter(abbrev_state == estado[i])
    n_citys <- nrow(my_citys_obj)
    my_citys_names <- my_citys_obj %>% pull(name_muni)
    resul[i] <- "Other"
    for(j in 1:n_citys){
      pol_city <- my_citys_obj$geom  %>%
        purrr::pluck(j) %>%
        as.matrix()
      if(def_pol(base_sigla_uf$lon[i],
                 base_sigla_uf$lat[i],
                 pol_city)){
        resul[i] <- my_citys_names[j]
      }
    }
  }
}
tictoc::toc()
base_sigla_uf$city_ref <- resul

get_geobr_city_n <- function(x, y, estado){
  my_citys_obj <- citys %>%
    tibble() %>%
    filter(abbrev_state == estado)
  n_citys <-  my_citys_obj %>% nrow()
  return(n_citys)
};get_geobr_city_n(-47.2, -23.1,"SP")

get_geobr_city <- function(arg){
  resul <- "Other"
    if(!is.na(arg)){
    arg <- as.vector(as.character(arg))
    marg <- str_split(arg," ",simplify = TRUE)
    n_citys <- marg[1,1] %>% as.numeric()
    x <- marg[1,2] %>% as.numeric()
    y <- marg[1,3] %>% as.numeric()
    estado <- marg[1,4]
    my_citys_obj <- citys %>%
      tibble() %>%
      filter(abbrev_state == estado)
    if(estado != "Other"){
      my_citys_names <- my_citys_obj %>% pull(name_muni)
      for(i in 1:n_citys){
        pol_city <- my_citys_obj$geom  %>%
          purrr::pluck(i) %>%
          as.matrix()
        if(def_pol(x, y, pol_city)){
          resul <- my_citys_names[i]
        }
      }
    }
  }
  return(resul)
};get_geobr_city(NA)

# tictoc::tic()
# base_sigla_uf <- base_sigla_uf %>%
#   group_by(sigla_uf) %>%
#   nest() %>%
#   #filter(sigla_uf != "DF") %>%
#   mutate(
#     nr = map(sigla_uf,
#              ~get_geobr_city_n(data$lon,
#                                data$lat,
#                                .x))
#   ) %>%
#   unnest(cols = c(data, nr)) %>%
#   ungroup() %>%
#   # sample_n(10) %>%
#   mutate(
#     list_par = str_c(nr, lon, lat, sigla_uf,sep=" "),
#   ) %>%
#   mutate(
#     city_ref = map(list_par,get_geobr_city)
#   ) %>%
#   unnest(cols = c(city_ref_2))
# tictoc::toc()

# Final da faxina ---------------------------------------------------------
# lendo arquivo da base nacional
brazil_ids <- read_rds("data/df_nome.rds")

# mesclando as bases
base_sigla_uf <- left_join(base_sigla_uf,brazil_ids %>%
            group_by(sigla_uf,nome_regiao) %>%
            summarise(count=n()) %>%
            select(sigla_uf,nome_regiao),
          by = c("sigla_uf"))

# Mesclando e salvando o arquivo final
dados_sigla <- left_join(
  dados,
  base_sigla_uf %>%
    ungroup() %>%
    select(source_name, lon, lat, sigla_uf, nome_regiao, biomes,
           flag_indigenous, flag_conservation, city_ref),
  by = c("source_name","lat","lon")
) %>% as_tibble()

dados_sigla$nome_regiao %>%  unique()

write_rds(dados_sigla %>%
             rename(biome = biomes), "data/emissions_sources.rds")

# country data -----------------------------------------------------------------
# buscando o caminho dos setores
tbl_directorys <- as_tibble(
  list.files("data-raw/BRA/", full.names = TRUE, recursive = TRUE)) %>%
  filter(str_detect(value, "country_emissions.csv"))

# Extraindo os caminhos dos arquvios
value <- tbl_directorys %>% pull(value)

# Empilhando todos os arquivos no objeto dados
my_file_read(value[1])
dados_country <- map_dfr(value, my_file_read) %>%
  as_tibble()
glimpse(dados_country)

dados_country <- dados_country %>%
  # filter(gas == "co2e_100yr") %>%
  mutate(
    start_time = as_date(start_time),
    end_time = as_date(end_time),
    created_date = as_date(created_date),
    modified_date = as_date(modified_date),
    year = lubridate::year(end_time)
  ) %>%
  mutate(
    sector_name = str_split(directory,
                            "/",
                            simplify = TRUE)[,3],
    sector_name = str_remove(sector_name,"_country_emissions.csv")
  )

dados_country$directory[1]

dados_country %>%
  select( sector_name ) %>%
  distinct()
write_rds(dados_country, "data/country_emissions.rds")
```

