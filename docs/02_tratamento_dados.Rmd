---
title: "02_tratamento_dados"
output: html_document
date: "2025-04-28"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE, 
                      error = FALSE, 
                      warning = FALSE)
```

### üìÑ Sobre os Dados

Permiss√µes e Uso: Todos os dados do Climate TRACE est√£o dispon√≠veis gratuitamente sob a Licen√ßa P√∫blica Internacional Creative Commons Atribui√ß√£o 4.0, salvo indica√ß√£o em contr√°rio.

Forma sugerida de cita√ß√£o: Para fontes de diferentes setores ou dados globais acessados e baixados, utilize a seguinte cita√ß√£o: Climate TRACE (2025). Climate TRACE Emissions Inventory v4.2.0. Dispon√≠vel em: <https://climatetrace.org>. Acessado em: **28/04/2025**.

Para cita√ß√µes espec√≠ficas por setor, consulte a se√ß√£o correspondente na plataforma.

### üìÅ Arquivos Dispon√≠veis

A seguir, uma breve descri√ß√£o dos arquivos inclu√≠dos no pacote de dados baixado da plataforma Climate TRACE:

-   `detailed_data_schema.csv` - Arquivo com o mapeamento e a explica√ß√£o do significado de cada coluna dos dados para todos os diferentes subsetores.

-   `<nome-do-subsetor>_emissions_sources.csv` - Cont√©m os dados de emiss√µes no n√≠vel de fonte de emiss√£o para todos os subsetores monitorados pela Climate TRACE.

-   `<nome-do-subsetor>_country_emissions.csv` - Cont√©m os dados de emiss√µes no n√≠vel de pa√≠s para todos os subsetores monitorados pela Climate TRACE.

-   `<nome-do-subsetor>_emissions_sources_confidence.csv` - Arquivo que especifica a classifica√ß√£o de confian√ßa dos dados reportados pelas fontes de emiss√£o, referenciando o arquivo <subsetor>\_emissions_sources.csv.

-   `<nome-do-subsetor>_emissions_sources_ownership.csv` - Cont√©m informa√ß√µes sobre a propriedade das fontes de emiss√£o listadas no arquivo `<subsetor>_emissions_sources.csv.`

üîó Observa√ß√£o: A lista completa de setores de emiss√£o para os quais a Climate TRACE fornece dados est√° dispon√≠vel no site: <https://climatetrace.org/sectors>.

Para alguns setores, h√° dados geoespaciais adicionais n√£o inclu√≠dos neste pacote de download. Para solicit√°-los, entre em contato pelo e-mail: [coalition\@climatetrace.org](mailto:coalition@climatetrace.org){.email}.

### üìÑ Sobre os Dados

Para mais informa√ß√µes sobre a origem, metodologia e estrutura dos dados utilizados, acesse o documento oficial disponibilizado pela Climate TRACE:

### üì• Clique aqui para baixar o arquivo [about_the_data.pdf](https://arpanosso.github.io//mestrado-durigan-remocoes-co2//about_the_data.pdf) e [about_the_data_v4_2_0.pdf](https://arpanosso.github.io//mestrado-durigan-remocoes-co2//about_the_data_v4_2_0.pdf)

### üîçüìÅ Encontrando os arquivos `.csv`

Para esta an√°lise, vamos utilizar os arquivos no formato:

`<nome-do-subsetor>_country_emissions.csv`

Esses arquivos cont√™m as estimativas anuais/mensais de emiss√µes e remo√ß√µes de CO‚ÇÇ organizadas por munic√≠pio, subsetor e etc.

```{r}
emissions_sources_files <- list.files("../data-raw/",
             full.names = TRUE,
             recursive = TRUE,
           pattern = "emissions_sources_v4_2_0.csv")
```

### üõ†Ô∏è Criando fun√ß√£o para ler $1$ arquivo

A fun√ß√£o `my_file_read` recebe o caminho de um arquivo `.csv` como entrada, l√™ o conte√∫do do arquivo, remove as colunas que come√ßam com "other" (colunas auxiliares menos relevantes para a an√°lise), e adiciona uma nova coluna chamada `directory` contendo o caminho original do arquivo, √∫til para rastrear a origem dos dados em etapas subsequentes.

```{r}
my_file_read <- function(file_path) {
  read.csv(file_path, 
           stringsAsFactors = FALSE)  |> 
    # dplyr::select(!dplyr::starts_with("other")) |> 
    dplyr::mutate(dplyr::across(dplyr::starts_with("other"),as.character)) |> 
    dplyr::mutate(
      directory = file_path,
      native_source_id = as.character(native_source_id))
}
```

### üß© Aplicando a fun√ß√£o de leitura aos arquivos

`emissions_sources_files`: cont√©m os caminhos completos dos arquivos .csv que queremos importar (obtidos com list.files()).

`my_file_read`: √© a fun√ß√£o definida anteriormente que realiza a leitura e pequenas transforma√ß√µes no arquivo.

`map_dfr()`: aplica a fun√ß√£o a cada arquivo da lista e junta tudo em um √∫nico data.frame. `map` vem do conceito de programa√ß√£o funcional chamado "mapear uma fun√ß√£o sobre uma estrutura de dados". Isso significa: **Aplicar uma fun√ß√£o a cada elemento de um vetor ou lista, retornando uma nova estrutura com os resultados**.

`glimpse()`: mostra um resumo estruturado dos dados finais.

```{r}
# Empilhando todos os arquivos no objeto dados, pela Aplican√ß√£o 
# da fun√ß√£o a todos os arquivos encontrados
dados_emissoes <- purrr::map_dfr(
  emissions_sources_files, 
  my_file_read)
```

### üõ†Ô∏è Tratamento (preprocessing/transformation):

Agora precisamos converter tipos de dados (como de character para Date), criar novas vari√°veis (como o year a partir de end_time) e reorganizar ou transformar vari√°veis para an√°lise.

**Corre√ß√µes nominais**

Criamos uma tabela de corre√ß√µes para padronizar nomes de localidades com acentua√ß√£o incorreta ou varia√ß√µes de grafia observadas nos dados originais.

```{r}
correcoes <- c(
  "Itapoa" = "Itapo√°",
  "Maraba" = "Marab√°",
  "Ribeirao" = "Ribeir√£o",
  "Sao Goncalo" = "S√£o Gon√ßalo",
  "Sao Jose" = "S√£o Jos√©",
  "Ribeirao" = "Ribeir√£o",
  "Ceil√¢ndia" = "Bras√≠lia",
  "Gama" = "Bras√≠lia",
  "Itapo√£" = "Bras√≠lia",
  "Icaivera" = "Betim",
  "Taquaralto" = "Palmas",
  "S√£o Jo√£o del-Rei" = "S√£o Jo√£o del Rei"
)
```

**Tratamento de nomes e tipos de fonte**

Aplicou-se a tabela de corre√ß√µes aos nomes das fontes emissoras (`source_name`) e foram atribu√≠dos os tipos de fonte (`source_type`) quando ausentes, com base em padr√µes contidos nos nomes originais. Al√©m disso, foi criada uma nova coluna com o nome da fonte tratado (`source_name_trat`), removendo os sufixos descritivos como `"Municipality"` e `"Urban Area"`. Em adi√ß√£o a coluna `directory`, que armazena o caminho dos arquivos originais, foi tratada para remover trechos desnecess√°rios, mantendo apenas a estrutura hier√°rquica √∫til √† an√°lise. Por fim, as colunas foram reorganizadas para facilitar a visualiza√ß√£o e manuseio dos dados, colocando identificadores e nomes das fontes no in√≠cio da tabela.

```{r}
dados_emissoes <- dados_emissoes |> 
  dplyr::mutate(
    start_time = lubridate::as_date(start_time),
    end_time = lubridate::as_date(end_time),
    created_date = lubridate::as_date(created_date),
    modified_date = lubridate::as_date(modified_date),
    year = lubridate::year(end_time),
    month = lubridate::month(end_time),
    source_name = stringr::str_replace_all(source_name, correcoes),
    source_type = ifelse(is.na(source_type),
                         ifelse(stringr::str_detect(source_name,"Municipality"),
                                "Municipality",          ifelse(stringr::str_detect(source_name,"Urban Area"),"Urban Area",NA)),source_type),source_name_trat = stringr::str_remove(source_name,
  " Municipality| Urban Area"),
    directory = stringr::str_remove(
      directory,"../data-raw/BRA/DATA/|_emissions_sources_v4_2_0.csv"
    ),
  ) |> 
  dplyr::relocate(source_id, source_name, source_name_trat)
dplyr::glimpse(dados_emissoes)
```

Devido √† exit√™ncia de valores de coordenadas como valores `NA`, associados √† fontes do tipo `"Urban Area"`, esse trecho de c√≥digo realiza tratamento geoespacial, garantindo que cada fonte emissora do tipo `"Municipality"` esteja corretamente associada a uma coordenada geogr√°fica (latitude e longitude). O objeto `dados_emissoes_municipality` √© criado e ser√° usado dentro das fun√ß√µes a seguir busca de coordenadas geogr√°ficas e substitui√ß√£o de `NAs`.

```{r}
dados_emissoes_municipality <-  dados_emissoes |> 
  dplyr::filter(source_type == "Municipality") |> 
  dplyr::group_by(source_name_trat,lat,lon) |> 
  dplyr::summarise(
    lon = mean(lon, na.rm=TRUE),
    lat = mean(lat, na.rm=TRUE)
  ) |> dplyr::ungroup()
```

#### üß© Fun√ß√µes auxiliares para busca de coordenadas

As fun√ß√µes `get_lat(muni)` e `get_lon(muni)` recebem um nome de munic√≠pio tratado, usam esse nome para filtrar a tabela `dados_emissoes_municipality` e retornam, respectivamente, a latitude e longitude associadas. O uso de `slice(1)` garante que apenas o primeiro valor seja retornado, mesmo que haja m√∫ltiplos registros. Portanto, √© uma fun√ß√£o de busca para preencher valores faltantes de `lat` e `lon` no `dados_emissoes`.

```{r}
get_lat <- function(muni){
  muni <- muni[1]
  lat <- dados_emissoes_municipality |> 
    dplyr::filter(source_name_trat == muni) |> dplyr::slice(1) |> dplyr::pull(lat)
  return(lat)
}

get_lon <- function(muni){
  muni <- muni[1]
  lon <- dados_emissoes_municipality |> 
    dplyr::filter(source_name_trat == muni) |> dplyr::slice(1) |> dplyr::pull(lon)
  return(lon)
}
```

### üîÑ Atualiza√ß√£o dos dados principais com coordenadas faltantes

Inicalmente agrupamos os dados por `source_name` (nome original da fonte emissora) para que a fun√ß√£o retorne os valores de `lat` e `lon` para cada `source_name_trat`. Em cada grupo, verifica-se `lat` ou `lon` est√° ausente. Se estiver, busca o valor correspondente nas tabelas auxiliares, usando as fun√ß√µes criadas. Se n√£o estiver ausente, mant√©m o valor original. Ao final, remove qualquer linha que ainda esteja sem `lat` (e, implicitamente, `lon`).

```{r}
dados_emissoes <- dados_emissoes |> 
  dplyr::group_by(source_name) |> 
  dplyr::mutate(
    lat=ifelse(is.na(lat),get_lat(source_name_trat),lat),
    lon=ifelse(is.na(lon),get_lon(source_name_trat),lon)
  ) |> 
  dplyr::filter(!is.na(lat))
```

### üåé Carregando dados geogr√°ficos do Brasil

Nesta etapa, utilizamos o pacote `{geobr}` para importar informa√ß√µes geogr√°ficas oficiais do Brasil. Esses dados s√£o importantes para an√°lises espaciais e visualiza√ß√µes no contexto ambiental e territorial. Os seguintes objetos s√£o criados:

-   `municipality`: Cont√©m os limites geogr√°ficos de todos os munic√≠pios brasileiros.

-   `states`: Cont√©m os limites geogr√°ficos de todos os estados brasileiros.

-   `biomes`: Traz os contornos dos biomas do Brasil (como Amaz√¥nia, Cerrado, Mata Atl√¢ntica, etc.).

-   `conservation`: Inclui os limites das Unidades de Conserva√ß√£o brasileiras, como parques nacionais e reservas ecol√≥gicas.

-   `indigenous`: Cont√©m as terras ind√≠genas oficialmente reconhecidas.

Essas camadas podem ser sobrepostas a dados de emiss√µes para entender a distribui√ß√£o espacial em rela√ß√£o a √°reas protegidas, territ√≥rios ind√≠genas ou regi√µes ecol√≥gicas espec√≠ficas.

Para maiores informa√ß√µes acesse [Introduction to geobr (R)](https://cran.r-project.org/web/packages/geobr/vignettes/intro_to_geobr.html)

```{r}
country_br <- geobr::read_country(showProgress = FALSE)
municipality <- geobr::read_municipality(showProgress = FALSE)|> 
  dplyr::rename(target = name_muni )
states <- geobr::read_state(showProgress = FALSE) |> 
  dplyr::rename(target = abbrev_state )
biomes <- geobr::read_biomes(showProgress = FALSE) |> 
  dplyr::rename(target = name_biome)
conservation <- geobr::read_conservation_units(showProgress = FALSE) |> 
  dplyr::rename(target = name_conservation_unit)
indigenous <- geobr::read_indigenous_land(showProgress = FALSE) |> 
  dplyr::rename(target = terrai_nom)
```

### üó∫Ô∏è Plotando espacialmente os ponto

Nesta etapa, vamos representar os dados no espa√ßo geogr√°fico, gerando mapas que permitem visualizar a distribui√ß√£o dos pontos de interesse. A plotagem espacial √© fundamental para identificar padr√µes, √°reas de maior concentra√ß√£o e poss√≠veis anomalias nos dados.

Criando o mapa com sobreposi√ß√£o

Terras Ind√≠genas reconhecidas

```{r}
indigenous    |> 
  ggplot2::ggplot() +
  ggplot2::geom_sf(fill="white", color="black",
          size=.15, show.legend = FALSE) +
  ggplot2::geom_point(
    data = dados_emissoes  |> 
      dplyr::filter(
        year == 2021),
     ggplot2::aes(lon,lat)) +
  ggplot2::theme_bw()
```

√Åreas de conserva√ß√£o

```{r}
conservation    |> 
  ggplot2::ggplot() +
  ggplot2::geom_sf(fill="white", color="black",
          size=.15, show.legend = FALSE) +
  ggplot2::geom_point(
    data = dados_emissoes  |> 
      dplyr::filter(
        year == 2021),
     ggplot2::aes(lon,lat)) +
  ggplot2::theme_bw()
```

### üß≠ Fun√ß√£o para verificar se pontos est√£o dentro de um pol√≠gono

A fun√ß√£o `def_pol()` tem como objetivo **verificar se pontos (definidos por coordenadas `x` e `y`) est√£o dentro de um pol√≠gono geogr√°fico**.

Ela utiliza a fun√ß√£o `point.in.polygon()` do pacote `{sp}` para realizar essa verifica√ß√£o espacial. Isso √© √∫til para saber, por exemplo, **quais fontes de emiss√£o est√£o dentro de um determinado bioma ou unidade de conserva√ß√£o**.

```{r}
def_pol <- function(x, y, pol){
  as.logical(sp::point.in.polygon(
    point.x = x,         # Coordenadas X dos pontos
    point.y = y,         # Coordenadas Y dos pontos
    pol.x = pol[,1],     # Coordenadas X do pol√≠gono (coluna 1 do objeto pol)
    pol.y = pol[,2]      # Coordenadas Y do pol√≠gono (coluna 2 do objeto pol)
  ))
}
```

### üß© Fun√ß√£o `get_geobr_pol()`

A fun√ß√£o tem como entrada: um √≠ndice `i` e um objeto do `{geobr}` (geobr_obj) ‚Äî que cont√©m geometrias (como states, biomes, etc.). O processo acessa o slot `$geom`, que √© uma lista de geometrias (um sfc do `{sf}`), usa `purrr::pluck(i)` para pegar a geometria do estado `i` (ex: 1¬∫ estado) e converte essa geometria (um POLYGON ou MULTIPOLYGON) em uma matriz com `as.matrix()` ‚Äî essencial para usar em fun√ß√µes como `point.in.polygon()` depois. A sa√≠da da fun√ß√£o √© uma matriz com as coordenadas do pol√≠gono do estado selecionado.

```{r}
get_geobr_pol <- function(i, geobr_obj) {
  pol<-geobr_obj$geom |> 
    purrr::pluck(i) |> 
    as.matrix()
  return(pol) 
}
```

### üì¶ Fun√ß√£o `get_geobr()`

serve para determinar a qual unidade dentro do `geobr_obj` pertence um ponto geogr√°fico, com base nas coordenadas `x` (longitude) e `y` (latitude), a partir da geometria espec√≠fica.

```{r}
get_geobr <- function(x, y, geobr_obj){
  target <- geobr_obj$target
  list_pol <- purrr::map(
    1:nrow(geobr_obj), 
    get_geobr_pol,
    geobr_obj = geobr_obj)
  names(list_pol) <- target
  
  x <- as.vector(x[1])
  y <- as.vector(y[1])
  resul <- "Other"

  for(i in 1:nrow(geobr_obj)){
    if(def_pol(x, y, list_pol[[i]])){
      resul <- names(list_pol[i])
      break
    } else {
      resul <- resul
    }
  }
  return(as.vector(resul))
}

# Testando da Fun√ß√£o
get_geobr(-47.9292, -15.7801, states) # ‚Üí "DF" (Bras√≠lia)
get_geobr(-47.9292, -15.7801, biomes) # ‚Üí "Cerrado"
get_geobr(-47.9292, -15.7801, conservation) # ‚Üí "Other"
get_geobr(-47.9292, -15.7801, indigenous) # ‚Üí "Other"
```

Vamos criar um arquivo com todos os pares de coordenadas que ocorrem na base de dados e classificar.

`dados_emissoes |> group_by(lon, lat)`: Agrupa os dados por coordenadas geogr√°ficas (longitude e latitude).

`summarise(year_m = mean(year))`: Faz um resumo calculando a m√©dia do ano (year), mas esse valor ser√° descartado logo em seguida.

`select(-year_m)`: Remove a coluna year_m, sobrando s√≥ lon e lat no resultado.

`mutate(...)`: Para cada par de (lon, lat), ele chama a fun√ß√£o get_geobr para classificar:

-   state ‚Üí qual estado o ponto pertence;

-   biome ‚Üí qual bioma o ponto pertence;

-   conservation ‚Üí se est√° em √°rea de unidade de conserva√ß√£o;

-   indigenous ‚Üí se est√° em terra ind√≠gena.

`write_rds(...)`: Salva o resultado (`base_sigla_uf`) em um arquivo `.rds` para usar depois sem precisar recalcular tudo.

```{r, eval=FALSE}
base_sigla_uf <- dados_emissoes |>
  dplyr::group_by(lon, lat) |>
  dplyr::summarise(
    year_m = mean(year)
  ) |>
  dplyr::select(-year_m) |>
  # tidyr::drop_na() |>
  dplyr::mutate(
    state = get_geobr(lon, lat, states),
    biome = get_geobr(lon, lat, biomes),
    conservation = get_geobr(lon, lat, conservation),
    indigenous = get_geobr(lon, lat, indigenous)
  )
readr::write_rds(base_sigla_uf,"../data/states_biom_conser_ind-br.rds")
```

Criando uma nova coluna chamada `biomes` que √© uma vers√£o "ajustada" do `biome` Faz v√°rias reclassifica√ß√µes baseadas em: Nome original do bioma (`biome`) e condi√ß√µes de latitude (`lat`) e longitude (`lon`).

```{r}
base_sigla_uf <- readr::read_rds("../data/states_biom_conser_ind-br.rds")
base_sigla_uf <- base_sigla_uf |>
  dplyr::mutate(
    biomes_sig =
      dplyr::case_when(
        biome=='Other'& lon >=-45 & lat <0~'AF',
        biome=='Amaz√¥nia'~'AMZ',
        biome=='Other'& lon < -45 & lat >=-10 ~'AMZ',
        biome == 'Mata Atl√¢ntica' & lon> -40 & lat < -20 ~'Other',
        biome == 'Mata Atl√¢ntica' & lon> -34 & lat > -5 ~'Other',
        biome == 'Mata Atl√¢ntica' ~ 'AF',
        biome=='Cerrado'~'CERR',
        biome =='Pampa'~'PMP',
        biome == 'Pantanal' ~ 'PNT',
        biome=='Caatinga'~'CAAT',
        .default = 'Other'
      )
    )
```

### üì¶ Fun√ß√£o `get_geobr_municipaly()`

serve para determinar a qual munic√≠pio a partir do estado pertence um ponto geogr√°fico, com base nas coordenadas `x` (longitude) e `y` (latitude), o estado a partir da geometria do municipio `municipaly`.

```{r}
get_geobr_municipaly <- function(x, y, state, geobr_obj){
  state <- as.vector(state[1])
  x <- as.vector(x[1])
  y <- as.vector(y[1])
  resul <- "Other"
  if(state == "Other") {return(resul)}
  geobr_obj <- geobr_obj |> 
    dplyr::filter(abbrev_state == state)
  target <- geobr_obj$target
  list_pol <- purrr::map(
    1:nrow(geobr_obj), 
    get_geobr_pol,
    geobr_obj = geobr_obj)
  names(list_pol) <- target
  
  for(i in 1:nrow(geobr_obj)){
    if(def_pol(x, y, list_pol[[i]])){
      resul <- names(list_pol[i])
      break
    } else {
      resul <- resul
    }
  }
  return(as.vector(resul))
}

# Testando da Fun√ß√£o
get_geobr_municipaly(-47.9292, -15.7801, "DF",municipality) # ‚Üí (Bras√≠lia)
get_geobr_municipaly(-47.2, -23.1,"SP", municipality) # ‚Üí (Indaiatuba)
get_geobr_municipaly(-57.97413, -22.18186,"SP", municipality) # ‚Üí (Other)
```

Vamos criar uma nova base com os pontos classificados por munic√≠pio

```{r, eval= FALSE}
base_sigla_uf_muni <- base_sigla_uf |> 
  dplyr::mutate(
    muni = get_geobr_municipaly(lon, lat, state, municipality)
  )
```

### üìÅ Mesclando e Salvando a base

Buscar as regi√µes do Brasil a partir de dados oficiais do IBGE, previamente salvos em `df_nome.rds`. Posteriormente, vamos mesclar as bases e salvar na pasta `data` com o nome `emissions_sources.rds`.

```{r, eval = FALSE}
brazil_ids <- readr::read_rds("../data/df_nome.rds")
base_sigla_region <- dplyr::left_join(base_sigla_uf_muni,brazil_ids  |> 
                                        dplyr::group_by(sigla_uf,nome_regiao) |> 
                                        dplyr::summarise(count=dplyr::n()) |> 
                                        dplyr::select(sigla_uf,nome_regiao) |>
                                        dplyr::rename(state = sigla_uf,region = nome_regiao),
                                      by = c("state"))
dplyr::left_join(
  dados_emissoes,
  base_sigla_region |> 
    dplyr::ungroup(),
  by = c("lat","lon")
) |> 
  tibble::as_tibble() |> 
  readr::write_rds( "../data/emissions_sources.rds")
```
